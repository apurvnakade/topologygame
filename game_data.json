{"name": "Lean Topology game", "version": "1.0.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Lean Topology game-1.0.0-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 4, "objects": [{"type": "tactic", "content": "3", "name": "refl", "sideBar": true}, {"type": "text", "content": "4"}, {"type": "hint", "content": "5", "title": "6"}, {"type": "lean", "content": "7", "hidden": true}, {"type": "lemma", "text": "8", "lean": "lemma union_is_union (A B : set X) : A \u222a B = A \u222a B :=\n", "sideBar": false, "firstProofLineNumber": 43, "lastProofLineNumber": 44, "textBefore": "/- Tactic : refl\n\n## Summary\n\n`refl` proves goals of the form `X = X`.\n\n## Details\n\nThe `refl` tactic will close any goal of the form `A = B`\nwhere `A` and `B` are *exactly the same thing*.\n\n### Example:\nIf it looks like this in the top right hand box:\n```\na b c d : mynat\n\u22a2 (a + b) * (c + d) = (a + b) * (c + d)\n```\n\nthen\n\n`refl,`\n\nwill close the goal and solve the level. Don't forget the comma.\n\n-/\n\n/-\nWe will start by practising with the simplest tactic, namely *refl*. This just proves goals\nof the form $A = A$, no matter how complicated $A$ is. Let's see it in action!\n-/\n\n/- Hint : Click here for a hint, in case you get stuck.\nJust delete `sorry` and type `refl,` (don't forget the comma!).\n-/\n\nvariables {X : Type} -- hide\n\n/- Lemma : no-side-bar\nIf A and B are sets, then A \u222a B = A \u222a B.\n-/\nlemma union_is_union (A B : set X) : A \u222a B = A \u222a B :=\nbegin\n", "proof": "  refl,\n  ", "textAfter": "\nend", "height": 2, "editorText": "sorry", "lineOffset": 42, "name": "union_is_union", "statement": "(A B : set X) : A \u222a B = A \u222a B"}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "tactic", "content": "9", "name": "rw", "sideBar": true}, {"type": "text", "content": "10"}, {"type": "hint", "content": "11", "title": "12"}, {"type": "lean", "content": "13", "hidden": true}, {"type": "lemma", "text": "14", "lean": "lemma union_eq (A B C: set X) (h : A = B) : A \u222a C = B \u222a C :=\n", "sideBar": false, "firstProofLineNumber": 83, "lastProofLineNumber": 84, "textBefore": "/- Tactic : rw\n\n## Summary\n\nIf `h` is a proof of `X = Y`, then `rw h,` will change\nall `X`s in the goal to `Y`s. Variants: `rw \u2190 h` (changes\n`Y` to `X`) and\n`rw h at h2` (changes `X` to `Y` in hypothesis `h2` instead\nof the goal).\n\n## Details\n\nThe `rw` tactic is a way to do \"substituting in\". There\nare two distinct situations where use this tactics.\n\n1) If `h : A = B` is a hypothesis (i.e., a proof of `A = B`)\nin your local context (the box in the top right)\nand if your goal contains one or more `A`s, then `rw h`\nwill change them all to `B`'s. \n\n2) The `rw` tactic will also work with proofs of theorems\nwhich are equalities (look for them in the drop down\nmenu on the left, within Theorem Statements).\n\nImportant note: if `h` is not a proof of the form `A = B`\nor `A \u2194 B` (for example if `h` is a function, an implication,\nor perhaps even a proposition itself rather than its proof),\nthen `rw` is not the tactic you want to use. For example,\n`rw (P = Q)` is never correct: `P = Q` is the true-false\nstatement itself, not the proof.\nIf `h : P = Q` is its proof, then `rw h` will work.\n\nPro tip 1: If `h : A = B` and you want to change\n`B`s to `A`s instead, try `rw \u2190h` (get the arrow with `\\l` and\nnote that this is a small letter L, not a number 1).\n\n### Example:\nIf it looks like this in the top right hand box:\n```\nA B C : set X\nh : A = B \u222a C\n\u22a2 A \u222a B = B \u222a C\n```\n\nthen\n\n`rw h,`\n\nwill change the goal into `\u22a2 B \u222a C \u222a B = B \u222a C`.\n\n### Example: \nYou can use `rw` to change a hypothesis as well. \nFor example, if your local context looks like this:\n```\nA B C D : set X\nh1 : A = B \u2229 C\nh2 : B \u222a A = D\n\u22a2 D = B\n```\nthen `rw h1 at h2` will turn `h2` into `h2 : B \u222a B \u2229 C = D` (remember operator precedence).\n-/\n\n\n/-\nThe next tactic we will learn is *rw* (from rewrite). It rewrites equalities. That is,\nif we have a proof `h : x = 3` and we want to prove `\u22a2 x + 1 = 4`, then after `rw h` the goal\nwill become `\u22a2 3 + 1 = 4`, which seems reasonable.\n\n-/\n\n/- Hint : Click here for a hint, in case you get stuck.\nDelete `sorry` and type `rw h,` (don't forget the comma!). Lean tries `refl` afterwards,\nso you will see that this suffices.\n-/\n\nvariables {X : Type} -- hide\n\n/- Lemma : no-side-bar\nIf A, B and C are sets and A = B, then A \u222a C = B \u222a C.\n-/\nlemma union_eq (A B C: set X) (h : A = B) : A \u222a C = B \u222a C :=\nbegin\n", "proof": "  rw h,\n  ", "textAfter": "\nend", "height": 2, "editorText": "sorry", "lineOffset": 82, "name": "union_eq", "statement": "(A B C: set X) (h : A = B) : A \u222a C = B \u222a C"}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "tactic", "content": "15", "name": "exact", "sideBar": true}, {"type": "text", "content": "16"}, {"type": "hint", "content": "17", "title": "18"}, {"type": "lean", "content": "19", "hidden": true}, {"type": "lemma", "text": "20", "lean": "lemma example_on_exact (A B : set X) (x : X) (h1 : x \u2208 A) (h2 : A = B) : x \u2208 B :=\n", "sideBar": false, "firstProofLineNumber": 48, "lastProofLineNumber": 50, "textBefore": "/- Tactic : exact\n\n## Summary \n\nIf the goal is `\u22a2 X` then `exact x` will close the goal if\nand only if `x` is a term of type `X`. \n\n## Details\n\nSay $P$, $Q$ and $R$ are types (i.e., what a mathematician\nmight think of as either sets or propositions),\nand the local context looks like this: \n\n```\np : P,\nh : P \u2192 Q,\nj : Q \u2192 R\n\u22a2 R\n```\n\nIf you can spot how to make a term of type `R`, then you\ncan just make it and say you're done using the `exact` tactic\ntogether with the formula you have spotted. For example the\nabove goal could be solved with\n\n`exact j(h(p)),`\n\nbecause $j(h(p))$ is easily checked to be a term of type $R$\n(i.e., an element of the set $R$, or a proof of the proposition $R$).\n\n-/\n\n/-\nIn this level we learn the tactic `exact`, which solves a goal that is exactly one of the hypotheses.\n-/\n\n/- Hint : Click here for a hint, in case you get stuck.\nBy doing a `rw` you will get the goal to look exactly like one of the hypotheses...\n-/\n\nvariables {X : Type} -- hide\n\n/- Lemma : no-side-bar\nIf A and B are sets and x \u2208 A and A = B, then x \u2208 B.\n-/\nlemma example_on_exact (A B : set X) (x : X) (h1 : x \u2208 A) (h2 : A = B) : x \u2208 B :=\nbegin\n", "proof": "  rw \u2190 h2,\n  exact h1,\n  ", "textAfter": "\nend\n", "height": 3, "editorText": "sorry", "lineOffset": 47, "name": "example_on_exact", "statement": "(A B : set X) (x : X) (h1 : x \u2208 A) (h2 : A = B) : x \u2208 B"}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "tactic", "content": "21", "name": "rwa", "sideBar": true}, {"type": "text", "content": "22"}, {"type": "lean", "content": "23", "hidden": true}, {"type": "lemma", "text": "24", "lean": "lemma example_on_rwa (A : set X) (x : X) (h1 : x \u2208 A) (h2 : A \u222a A = A) : x \u2208 A \u222a A :=\n", "sideBar": false, "firstProofLineNumber": 22, "lastProofLineNumber": 25, "textBefore": "/- Tactic : rwa\n\n\n`rwa` uses the rewrite tactic and then uses `exact` with all \nthe assumptions of the proof.\n\n-/\n\n\n/- \nThe next tactic we will learn is `rwa` which applies rewrite tactic and then uses `exact` with all the hypotheses.\n-/\n\n\nvariables {X : Type} -- hide\n\n/- Lemma : no-side-bar\nLet A be a set and x \u2208 A, using the assumption A \u222a A = A, we obtain that x \u2208 B.\n-/\nlemma example_on_rwa (A : set X) (x : X) (h1 : x \u2208 A) (h2 : A \u222a A = A) : x \u2208 A \u222a A :=\nbegin\n", "proof": "  rwa h2,\n  \n\n", "textAfter": "\nend", "height": 4, "editorText": "sorry", "lineOffset": 21, "name": "example_on_rwa", "statement": "(A : set X) (x : X) (h1 : x \u2208 A) (h2 : A \u222a A = A) : x \u2208 A \u222a A"}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "tactic", "content": "25", "name": "intro", "sideBar": true}, {"type": "text", "content": "26"}, {"type": "hint", "content": "27", "title": "28"}, {"type": "lean", "content": "29", "hidden": true}, {"type": "lemma", "text": "30", "lean": "lemma example_on_intro (A B : set X) (x : X) (h : A = B) : x \u2208 A \u2192 x \u2208 B :=\n", "sideBar": false, "firstProofLineNumber": 50, "lastProofLineNumber": 54, "textBefore": "/- Tactic : intro\n\n## Summary:\n\n`intro p` will turn a goal `\u22a2 P \u2192 Q` into a hypothesis `p : P`\nand goal `\u22a2 Q`. If `P` and `Q` are sets `intro p` means \"let $p$ be an arbitrary element of $P$\".\nIf `P` and `Q` are propositions then `intro p` says \"assume $P$ is true\". \n\n## Details\n\nIf your goal is a function or an implication `\u22a2 P \u2192 Q` then `intro`\nwill always make progress. `intro p` turns\n\n`\u22a2 P \u2192 Q`\n\ninto \n\n```\np : P\n\u22a2 Q\n```\n\nThe opposite tactic to intro is `revert`; given the situation\njust above, `revert p` turns the goal back into `\u22a2 P \u2192 Q`.\n\n## Example\n\nIf your goal is an implication $P\\implies Q$ then Lean writes\nthis as `\u22a2 P \u2192 Q`, and `intro p,` can be thought of as meaning\n\"let $p$ be a proof of $P$\", or more informally \"let's assume that\n$P$ is true\". The goal changes to `\u22a2 Q` and the hypothesis `p : P`\nappears in the local context.\n-/\n\n/-\nIn this level we introduce the tactic `intro`. You will need it to get started.\n-/\n\n/- Hint : Click here for a hint, in case you get stuck.\nTry something like `intro h1,` and go from there.\n-/\n\nvariables {X : Type} -- hide\n\n/- Lemma : no-side-bar\nIf A, B and C are sets and A = B, then A \u222a C = B \u222a C.\n-/\nlemma example_on_intro (A B : set X) (x : X) (h : A = B) : x \u2208 A \u2192 x \u2208 B :=\nbegin\n", "proof": "  intro h1,\n  rw \u2190 h,\n  exact h1,\n  \n  ", "textAfter": "\nend\n\n", "height": 5, "editorText": "sorry", "lineOffset": 49, "name": "example_on_intro", "statement": "(A B : set X) (x : X) (h : A = B) : x \u2208 A \u2192 x \u2208 B"}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "31", "hidden": true}, {"type": "lean", "content": "32", "hidden": true}, {"type": "tactic", "content": "33", "name": "apply", "sideBar": true}, {"type": "text", "content": "34"}, {"type": "hint", "content": "35", "title": "36"}, {"type": "lean", "content": "37", "hidden": true}, {"type": "lemma", "text": "38", "lean": "lemma subset_transitive_basic (A B C : set X) (x : X) (hAB : x \u2208 A \u2192 x \u2208 B) (hBC : x \u2208 B \u2192 x \u2208 C) :\n  x \u2208 A \u2192 x \u2208 C :=\n", "sideBar": false, "firstProofLineNumber": 42, "lastProofLineNumber": 47, "textBefore": "import data.set.basic -- hide\nopen set -- hide\n/- Tactic : apply\n\n## Summary\n\nIf `h : P \u2192 Q` is a hypothesis, and the goal is `\u22a2 Q` then\n`apply h` changes the goal to `\u22a2 P`. \n\n## Details\n\nIf you have a function `h : P \u2192 Q` and your goal is `\u22a2 Q`\nthen `apply h` changes the goal to `\u22a2 P`. The logic is\nsimple: if you are trying to create a term of type `Q`,\nbut `h` is a function which turns terms of type `P` into\nterms of type `Q`, then it will suffice to construct a\nterm of type `P`. A mathematician might say: \"we need\nto construct an element of $Q$, but we have a function $h:P\\to Q$\nso it suffices to construct an element of $P$\". Or alternatively\n\"we need to prove $Q$, but we have a proof $h$ that $P\\implies Q$\nso it suffices to prove $P$\".\n\n-/\n\n/-\nIn this level we introduce the new tactic `apply`. Look at what it does and try to solve it!\n-/\n\n/- Hint : Click here for a hint, in case you get stuck.\nStart with an `intro`, then try to `apply` the right hypothesis.\n-/\n\nvariables {X Y : Type} -- hide\n\n/- Lemma : no-side-bar\nIf A, B and C are sets and x \u2208 A, and we know that x \u2208 A \u2192 x \u2208 B and that x \u2208 B \u2192 x \u2208 C, then\nwe can deduce that x \u2208 C.\n-/\nlemma subset_transitive_basic (A B C : set X) (x : X) (hAB : x \u2208 A \u2192 x \u2208 B) (hBC : x \u2208 B \u2192 x \u2208 C) :\n  x \u2208 A \u2192 x \u2208 C :=\nbegin\n", "proof": "  intro h,\n  apply hBC,\n  apply hAB,\n  exact h,\n\n  ", "textAfter": "\nend\n\n", "height": 6, "editorText": "sorry", "lineOffset": 41, "name": "subset_transitive_basic", "statement": "(A B C : set X) (x : X) (hAB : x \u2208 A \u2192 x \u2208 B) (hBC : x \u2208 B \u2192 x \u2208 C) :\n  x \u2208 A \u2192 x \u2208 C"}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "39", "hidden": true}, {"type": "lean", "content": "40", "hidden": true}, {"type": "text", "content": "41"}, {"type": "hint", "content": "42", "title": "43"}, {"type": "lean", "content": "44", "hidden": true}, {"type": "lemma", "text": "45", "lean": "lemma subset_transitive (A B C : set X) (hAB : A \u2286 B) (hBC : B \u2286 C) :\n  A \u2286 C :=\n", "sideBar": false, "firstProofLineNumber": 28, "lastProofLineNumber": 34, "textBefore": "import data.set.basic -- hide\nopen set -- hide\n\n/-\nThere is an equivalence between set theory and logic, and Lean identifies these two.\n\nIn this equivalence, a logic statement P : X \u2192 true/false corresponds to the set\n$A = \\{ x : X | P(x) \\}$. Under this equivalence, logical implications P \u2192 Q translate into\nset inclusions A \u2286 B, and so on.\n\nThe goal of this lemma is to prove transitivity of set inclusion, giving almost the same\nproof as in the previous lemma.\n-/\n\n/- Hint : Click here for a hint, in case you get stuck.\nStart with `intro x,`, then do exactly as in the previous level.\n-/\n\nvariables {X Y : Type} -- hide\n\n/- Lemma : no-side-bar\nIf A, B and C are sets and, and we know A \u2286 B and B \u2286 C, then\nwe have A \u2286 C.\n-/\nlemma subset_transitive (A B C : set X) (hAB : A \u2286 B) (hBC : B \u2286 C) :\n  A \u2286 C :=\nbegin\n", "proof": "  intro x,\n  intro hA,\n  apply hBC,\n  apply hAB,\n  exact hA,\n\n  ", "textAfter": "\nend", "height": 7, "editorText": "sorry", "lineOffset": 27, "name": "subset_transitive", "statement": "(A B C : set X) (hAB : A \u2286 B) (hBC : B \u2286 C) :\n  A \u2286 C"}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "46", "hidden": true}, {"type": "lean", "content": "47", "hidden": true}, {"type": "tactic", "content": "48", "name": "exfalso", "sideBar": true}, {"type": "hint", "content": "49", "title": "50"}, {"type": "lean", "content": "51", "hidden": true}, {"type": "lemma", "text": "52", "lean": "lemma one_eq_zero_of_contradiction (A : set X) (x : X) (h1 : x \u2208 A) (h2 : x \u2209 A): 1 = 0 :=\n", "sideBar": false, "firstProofLineNumber": 32, "lastProofLineNumber": 36, "textBefore": "import data.set.basic -- hide\nopen set -- hide\n\n/- Tactic : exfalso\n\n## Summary\n\nChanges the goal to `\u22a2 false`.\n\n## Details\n\nThis may seem hard to prove,\nbut it is useful when we have a contradiction in the hypotheses.\n\nFor example, if we have `h : \u00ac P` as a hypothesis and we apply `exfalso`\nwe can then `apply h` to transform the goal into `\u22a2 P`.\n-/\n\n\n/- Hint : Click here for a hint, in case you get stuck.\nIn Lean, the  negation `\u00ac P` of a statement is a shorthand for `P \u2192 false`. Therefore\nstart with `exfalso`, and remember that negation is the same as `\u2192 false`.\n-/\n\nvariables {X Y : Type} -- hide\n\n/- Lemma : no-side-bar\nWe can prove that 1 equals 0 if we have a contradiction in our hypotheses.\n-/\nlemma one_eq_zero_of_contradiction (A : set X) (x : X) (h1 : x \u2208 A) (h2 : x \u2209 A): 1 = 0 :=\nbegin\n", "proof": "  exfalso,\n  apply h2,\n  exact h1,\n\n  ", "textAfter": "\nend\n", "height": 5, "editorText": "sorry", "lineOffset": 31, "name": "one_eq_zero_of_contradiction", "statement": "(A : set X) (x : X) (h1 : x \u2208 A) (h2 : x \u2209 A): 1 = 0"}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "53", "hidden": true}, {"type": "lean", "content": "54", "hidden": true}, {"type": "text", "content": "55"}, {"type": "hint", "content": "56", "title": "57"}, {"type": "lean", "content": "58", "hidden": true}, {"type": "lemma", "text": "59", "lean": "lemma inter_union (A B C : set X) : A \u2229 (B \u222a C) = (A \u2229 B) \u222a (A \u2229 C) :=\n", "sideBar": false, "firstProofLineNumber": 22, "lastProofLineNumber": 62, "textBefore": "import data.set.basic -- hide\nopen set -- hide\n\n/-\nThe following lemma can be proved using `ext`, `split`, `cases`, `left`, `right` tactics.\n\nIf you are lazy, the `finish` tactic will take the fun out of this exercise. So try to not use it.\n-/\n\n/- Hint : Click here for a hint, in case you get stuck.\nRemember that `x \u2208 A \u2229 B` is \"the same as\" `x \u2208 A \u2227 x \u2208 B`. Therefore if you have a hypothesis\nof the form `h : x \u2208 A \u2229 B` and your goal is `\u22a2 x \u2208 B`, you win by `exact h.2`.\n-/\n\nvariables {X Y : Type} -- hide\n\n/- Lemma : no-side-bar\nThe distributive property of \u2229 with respect to \u222a.\n-/\nlemma inter_union (A B C : set X) : A \u2229 (B \u222a C) = (A \u2229 B) \u222a (A \u2229 C) :=\nbegin\n", "proof": "  ext,\n  split,\n  {\n    intro h,\n    cases h,\n    cases h_right,\n    {\n      left,\n      split;\n      assumption,\n    },\n    {\n      right,\n      split;\n      assumption,\n    }\n  },\n  {\n    intro h,\n    cases h,\n    {\n      split,\n      {\n        exact h.1,\n      },\n      {\n        left,\n        exact h.2,\n      },\n    },\n    {\n      split,\n      {\n        exact h.1,\n      },\n      {\n        right,\n        exact h.2,\n      }\n    }\n  }", "textAfter": "\nend\n", "height": 41, "editorText": "sorry", "lineOffset": 21, "name": "inter_union", "statement": "(A B C : set X) : A \u2229 (B \u222a C) = (A \u2229 B) \u222a (A \u2229 C)"}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "60", "hidden": true}, {"type": "lean", "content": "61", "hidden": true}, {"type": "lean", "content": "62", "hidden": true}, {"type": "text", "content": "63"}, {"type": "hint", "content": "64", "title": "65"}, {"type": "lean", "content": "66", "hidden": true}, {"type": "lemma", "text": "67", "lean": "lemma sInter_of_inter (P : set X \u2192 Prop) (huniv : P univ) (hinter : \u2200 A B : set X, P A \u2192 P B \u2192 P (A \u2229 B))\n(S : set (set X)) (hfin : finite S) (hS : \u2200 s \u2208 S, P s) : P ( sInter S ) :=\n", "sideBar": false, "firstProofLineNumber": 30, "lastProofLineNumber": 45, "textBefore": "import data.set.basic -- hide\nimport data.set.finite -- hide\nopen set -- hide\n/-\nWe will use the following lemma when we start proving facts about topological spaces.\n\nIt seems clear that we want to use induction, so we can try to apply the `finite.induction_on`\nlemma. But be careful on how you apply it, or you will be left with an impossible goal.\n\nFor the inductive step, the lemmas `sInter_insert`, `mem_insert_iff` and `forall_eq_or_imp`\nmay be useful, as well as the `simp` tactic.\n-/\n\n/- Hint : Click here for a hint, in case you get stuck.\nThe `finite.induction_on` lemma allows to prove something of the form `P S` for all finite sets `S`.\nSo apply `finite.induction_on hfin` looks like it's making progress. However, the induction\nhypothesis you will be left with is too weak. Try instead starting with `revert hS`, and\nsee why this helps.\n-/\n\nvariables {X Y : Type} -- hide\n\n/- Lemma : no-side-bar\nIf P is a property of sets which is closed under pairwise intersection then it is also closed under\narbitrary finite interesctions.\n-/\nlemma sInter_of_inter (P : set X \u2192 Prop) (huniv : P univ) (hinter : \u2200 A B : set X, P A \u2192 P B \u2192 P (A \u2229 B))\n(S : set (set X)) (hfin : finite S) (hS : \u2200 s \u2208 S, P s) : P ( sInter S ) :=\nbegin\n", "proof": "  revert hS,\n  apply finite.induction_on hfin,\n  { \n    simp,\n    exact huniv,\n  },\n  {\n    intros U S hUS hSfin hind h,\n    have h : \u22c2\u2080 insert U S = (\u22c2\u2080 S) \u2229 U,\n    {\n      finish,\n    },\n    rw h,\n    apply hinter;\n    finish,\n  }", "textAfter": "\nend\n\n", "height": 16, "editorText": "sorry", "lineOffset": 29, "name": "sInter_of_inter", "statement": "(P : set X \u2192 Prop) (huniv : P univ) (hinter : \u2200 A B : set X, P A \u2192 P B \u2192 P (A \u2229 B))\n(S : set (set X)) (hfin : finite S) (hS : \u2200 s \u2208 S, P s) : P ( sInter S )"}]}]}, {"name": "68", "levels": [{"name": "", "problemIndex": 11, "objects": [{"type": "lean", "content": "69", "hidden": true}, {"type": "axiom", "content": "70", "name": "The total set (called `univ`) is open.", "sideBar": true}, {"type": "axiom", "content": "71", "name": "The intersection of two open sets is open.", "sideBar": true}, {"type": "axiom", "content": "72", "name": "The union of an arbitrary set of open sets is open.", "sideBar": true}, {"type": "axiom", "content": "73", "name": "The union over the empty set is empty.", "sideBar": true}, {"type": "text", "content": "74"}, {"type": "lean", "content": "75", "hidden": true}, {"type": "lean", "content": "76", "hidden": true}, {"type": "text", "content": "77"}, {"type": "lean", "content": "78", "hidden": true}, {"type": "hint", "content": "79", "title": "80"}, {"type": "lemma", "text": "81", "lean": "lemma is_open_empty {X : Type} [topological_space X] : is_open (\u2205 : set X) :=\n", "sideBar": true, "firstProofLineNumber": 43, "lastProofLineNumber": 52, "textBefore": "import basic_defs_world.definition -- hide\n\n/- Axiom : The total set (called `univ`) is open.\nuniv_mem : is_open set.univ\n-/\n\n/- Axiom : The intersection of two open sets is open.\ninter : \u2200 (U V : set X) (hA : is_open U) (hB : is_open V), is_open (U \u2229 V)\n-/\n\n/- Axiom : The union of an arbitrary set of open sets is open.\nunion : \u2200 (Y : set (set X)) (h : \u2200 U \u2208 Y, is_open U), is_open (\u22c3\u2080 Y)\n-/\n\n/- Axiom : The union over the empty set is empty.\nsUnion_empty : \u22c3\u2080 \u2205 = \u2205\n-/\n\n/-\n# Level 1 : The empty set is open.\n-/\nnoncomputable theory -- hide\nopen set -- hide\n\n/-\nIn many textbooks, one of the axioms of a topological space is that the empty set is open. This actually follows from the other axioms!\n-/\n\nnamespace topological_space -- hide\n\n\n/- Hint : Click here for a hint, in case you get stuck.\nIn Lean, sets are notation for logical statements. That is, the set\n`a \u2208 { x : X | P x }` means *the same as* `P a`. As a somewhat degenerate\nexample, `a \u2208 \u2205` means `false`.\n-/\n\n/- Lemma\nProve that the empty set is open.\n-/\nlemma is_open_empty {X : Type} [topological_space X] : is_open (\u2205 : set X) :=\nbegin\n", "proof": "  rw \u2190sUnion_empty,\n  apply union,\n  tauto,\n\n\n\n\n\n\n", "textAfter": "\nend\n\nend topological_space -- hide\n", "height": 10, "editorText": "sorry", "lineOffset": 42, "name": "is_open_empty", "statement": "{X : Type} [topological_space X] : is_open (\u2205 : set X)"}, {"type": "lean", "content": "82", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "83", "hidden": true}, {"type": "lean", "content": "84", "hidden": true}, {"type": "lean", "content": "85", "hidden": true}, {"type": "text", "content": "86"}, {"type": "lemma", "text": "87", "lean": "lemma open_of_union {X : Type} [topological_space X] {U V : set X}\n(hU : is_open U) (hV : is_open V): is_open (U \u222a V) :=\n", "sideBar": true, "firstProofLineNumber": 16, "lastProofLineNumber": 26, "textBefore": "import .level1 -- hide\nopen set --hide\nnamespace topological_space -- hide\n\n\n/-\n # Level 2: The union of two open sets is open\n-/\n\n/- Lemma\nProve that the union of two open sets is open.\n-/\nlemma open_of_union {X : Type} [topological_space X] {U V : set X}\n(hU : is_open U) (hV : is_open V): is_open (U \u222a V) :=\nbegin\n", "proof": "  let I : set (set X) := {U, V},\n  have H : \u22c3\u2080 I = U \u222a V := sUnion_pair U V,\n  rw \u2190H,\n  apply union I,\n  intros B hB,\n  replace hB : B = U \u2228 B = V, by tauto,\n  cases hB; {rw hB, assumption},\n\n\n\n", "textAfter": "\nend\n\nend topological_space --hide", "height": 11, "editorText": "sorry", "lineOffset": 15, "name": "open_of_union", "statement": "{X : Type} [topological_space X] {U V : set X}\n(hU : is_open U) (hV : is_open V): is_open (U \u222a V)"}, {"type": "lean", "content": "88", "hidden": true}]}], "parents": [0]}, {"name": "89", "levels": [{"name": "", "problemIndex": 9, "objects": [{"type": "lean", "content": "90", "hidden": true}, {"type": "axiom", "content": "91", "name": "A set A is the neighborhood of a point x if there is an open U such that $x \\in U \\subseteq A$.", "sideBar": true}, {"type": "axiom", "content": "92", "name": "A point x is an interior point of A if A is a neighborhood of x.", "sideBar": true}, {"type": "axiom", "content": "93", "name": "The interior of a set A is the set of all its interior points.", "sideBar": true}, {"type": "text", "content": "94"}, {"type": "lean", "content": "95", "hidden": true}, {"type": "lean", "content": "96", "hidden": true}, {"type": "lean", "content": "97", "hidden": true}, {"type": "lean", "content": "98", "hidden": true}, {"type": "lemma", "text": "99", "lean": "lemma interior_is_subset: interior A \u2286 A :=\n", "sideBar": true, "firstProofLineNumber": 35, "lastProofLineNumber": 45, "textBefore": "import interior_world.definition -- hide\n\n/- Axiom : A set A is the neighborhood of a point x if there is an open U such that $x \\in U \\subseteq A$.\nis_neighborhood : \u2203 U, is_open U \u2227 x \u2208 U \u2227 U \u2286 A\n-/\n\n/- Axiom : A point x is an interior point of A if A is a neighborhood of x.\nis_interior_point : is_neighborhood x A\n-/\n\n/- Axiom : The interior of a set A is the set of all its interior points. \ninterior : { x : X | is_interior_point x A }\n-/\n\n/-\nIn this world we will end up having three alternative definitions of the interior of a set. \nThis will be very useful, because at any point we will be able to choose the one that better fits our needs.\n\nFirst of all we need to figure out what properties does the interior of an arbitrary set have... So we start with an easy one:\n\n# Level 1: The interior is contained in the original set\n\n-/\nvariables {X : Type} -- hide\nvariables [topological_space X] (x : X)  (A : set X) -- hide\n\nnamespace topological_space -- hide\n\n@[simp]  -- hide\n/- Lemma\nThe interior of any set A is contained in the set A.\n-/\nlemma interior_is_subset: interior A \u2286 A :=\nbegin\n", "proof": "  rintros x \u27e8_, _\u27e9,\n  tauto,\n\n\n\n\n\n\n\n\n", "textAfter": "\nend\n\nend topological_space -- hide\n", "height": 11, "editorText": "sorry", "lineOffset": 34, "name": "interior_is_subset", "statement": "interior A \u2286 A"}, {"type": "lean", "content": "100", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "101", "hidden": true}, {"type": "text", "content": "102"}, {"type": "lean", "content": "103", "hidden": true}, {"type": "lean", "content": "104", "hidden": true}, {"type": "lean", "content": "105", "hidden": true}, {"type": "lemma", "text": "106", "lean": "lemma interior_def' : interior A = \u22c3\u2080 {U : set X | is_open U \u2227 U \u2286 A} :=\n", "sideBar": true, "firstProofLineNumber": 23, "lastProofLineNumber": 33, "textBefore": "import interior_world.level1 --hide\n\n\n/-\n\n# Level 2: Second definition of the interior\n\nBefore we keep proving properties of the iterior of an arbitrary set, we will prove an alternative definition of it.\n\n-/\nvariables {X : Type} -- hide\nvariables [topological_space X] (x : X)  (A : set X) -- hide\n\nnamespace topological_space -- hide\n\n\n/- Lemma\nThe interior of a set A is the union of all the open sets that it contains:\n$ \\operatorname{int}(A) = \\bigcup_{U \\subseteq A, U\\text{ open}} U$\n-/\nlemma interior_def' : interior A = \u22c3\u2080 {U : set X | is_open U \u2227 U \u2286 A} :=\nbegin\n", "proof": "  simp only [interior, is_neighborhood, set.sUnion],\n  ext,\n  norm_num,\n  tauto,\n\n\n\n\n\n\n", "textAfter": "\nend\n\nend topological_space -- hide\n", "height": 11, "editorText": "sorry", "lineOffset": 22, "name": "interior_def'", "statement": "interior A = \u22c3\u2080 {U : set X | is_open U \u2227 U \u2286 A}"}, {"type": "lean", "content": "107", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "108", "hidden": true}, {"type": "text", "content": "109"}, {"type": "lean", "content": "110", "hidden": true}, {"type": "lean", "content": "111", "hidden": true}, {"type": "lean", "content": "112", "hidden": true}, {"type": "lemma", "text": "113", "lean": "@[simp] lemma interior_is_open : is_open (interior A) :=\n", "sideBar": true, "firstProofLineNumber": 20, "lastProofLineNumber": 34, "textBefore": "import interior_world.level2 --hide\n\n/-\n\n# Level 3: The interior is open\n\n\n\n-/\nvariables {X : Type} -- hide\nvariables [topological_space X] (x : X)  (A : set X) -- hide\n\nnamespace topological_space -- hide\n\n/- Lemma\nThe interior of a set is open.\n-/\n@[simp] lemma interior_is_open : is_open (interior A) :=\nbegin\n", "proof": "  rw interior_def',\n  apply union,\n  rintros B \u27e8is_open_B, _\u27e9,\n  exact is_open_B,\n\n\n\n\n\n\n\n\n\n\n", "textAfter": "\nend\n\n\nend topological_space -- hide\n", "height": 15, "editorText": "sorry", "lineOffset": 19, "name": "lemma", "statement": "interior_is_open : is_open (interior A)"}, {"type": "lean", "content": "114", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "115", "hidden": true}, {"type": "text", "content": "116"}, {"type": "lean", "content": "117", "hidden": true}, {"type": "lean", "content": "118", "hidden": true}, {"type": "lean", "content": "119", "hidden": true}, {"type": "lemma", "text": "120", "lean": "lemma interior_maximal (B : set X) (h : B \u2286 A) (hopen : is_open B):\n  B \u2286 interior A :=\n", "sideBar": true, "firstProofLineNumber": 21, "lastProofLineNumber": 34, "textBefore": "import interior_world.level3 --hide\n\n/-\n\n# Level 4: The interior is ...\n\n\n\n-/\nvariables {X : Type} -- hide\nvariables [topological_space X] (x : X)  (A : set X) -- hide\n\nnamespace topological_space -- hide\n\n/- Lemma\nThe interior of a set ...\n-/\nlemma interior_maximal (B : set X) (h : B \u2286 A) (hopen : is_open B):\n  B \u2286 interior A :=\nbegin\n", "proof": "  intros x x_in_B,\n  rw interior_def',\n  use B,\n  exact \u27e8\u27e8hopen, h\u27e9, x_in_B\u27e9,\n\n\n\n\n\n\n\n\n\n", "textAfter": "\nend \n\nend topological_space -- hide\n", "height": 14, "editorText": "sorry", "lineOffset": 20, "name": "interior_maximal", "statement": "(B : set X) (h : B \u2286 A) (hopen : is_open B):\n  B \u2286 interior A"}, {"type": "lean", "content": "121", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "122", "hidden": true}, {"type": "text", "content": "123"}, {"type": "lean", "content": "124", "hidden": true}, {"type": "lean", "content": "125", "hidden": true}, {"type": "lean", "content": "126", "hidden": true}, {"type": "lemma", "text": "127", "lean": "lemma interior_def'': is_open B \u2227 B \u2286 A \u2227 (\u2200 U, U \u2286 A \u2192 is_open U \u2192 U \u2286 B) \u2194 B = interior A :=   \n", "sideBar": true, "firstProofLineNumber": 21, "lastProofLineNumber": 49, "textBefore": "import interior_world.level4 --hide\n/-\n\n# Level 5: Characterization of the interior\n\n\n\n-/\nvariables {X : Type} -- hide\nvariables [topological_space X] (x : X)  (A B : set X) -- hide\n\nnamespace topological_space -- hide\n\n/- Lemma\nThe interior of a set A is the biggest subset satisfying:\n - It is contained in A\n - It is open.\n-/\nlemma interior_def'': is_open B \u2227 B \u2286 A \u2227 (\u2200 U, U \u2286 A \u2192 is_open U \u2192 U \u2286 B) \u2194 B = interior A :=   \nbegin\n", "proof": "  split,\n  {\n    rintros \u27e8is_open_B, \u27e8B_subset_A, B_is_biggest_open\u27e9\u27e9,\n    ext1,\n    split,\n    {\n      apply interior_maximal A B B_subset_A is_open_B,\n    },\n    {\n      intro ha,\n      exact B_is_biggest_open (interior A) (interior_is_subset A) (interior_is_open A) ha,\n    },\n  },\n  {\n    intro,\n    subst B,\n    exact \u27e8interior_is_open A, \u27e8interior_is_subset A, interior_maximal A\u27e9\u27e9,\n  },\n\n\n\n\n\n\n\n\n\n\n", "textAfter": "\nend \n\nend topological_space -- hide\n", "height": 29, "editorText": "sorry", "lineOffset": 20, "name": "interior_def''", "statement": "is_open B \u2227 B \u2286 A \u2227 (\u2200 U, U \u2286 A \u2192 is_open U \u2192 U \u2286 B) \u2194 B = interior A"}, {"type": "lean", "content": "128", "hidden": true}]}], "parents": [1]}, {"name": "129", "levels": [{"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "130", "hidden": true}, {"type": "axiom", "content": "131", "name": "A topological space is a T\u2080 space if, from any two points in the topology, there exist and open set that contains one point and not the other", "sideBar": true}, {"type": "axiom", "content": "132", "name": "A topological space is a T\u2081 space if, from any two points in the topology, there exist and open set that contains the first point and not the second", "sideBar": true}, {"type": "text", "content": "133"}, {"type": "lean", "content": "134", "hidden": true}, {"type": "lean", "content": "135", "hidden": true}, {"type": "lean", "content": "136", "hidden": true}, {"type": "lemma", "text": "137", "lean": "lemma T1_is_T0: T1_space X \u2192 T0_space X :=\n", "sideBar": true, "firstProofLineNumber": 26, "lastProofLineNumber": 39, "textBefore": "import separation_world.definition -- hide\n\n/- Axiom : A topological space is a T\u2080 space if, from any two points in the topology, there exist and open set that contains one point and not the other\nt0 : \u2200 (x y : X) (h : y \u2260 x) , \u2203 (U : set X) (hU : is_open U), ((x \u2208 U) \u2227 (y \u2209 U)) \u2228 ((x \u2209 U) \u2227 (y \u2208 U))\n-/\n\n/- Axiom : A topological space is a T\u2081 space if, from any two points in the topology, there exist and open set that contains the first point and not the second\nt1 : \u2200 (x y : X) (h : y \u2260 x), \u2203 (U : set X) (hU : is_open U), (x \u2208 U) \u2227 (y \u2209 U)\n-/\n\n/-\n\n# Level 1: Every Frechet space is a T\u2080 space\n\n-/\nvariables {X : Type} -- hide\nvariables [topological_space X] -- hide\n\nnamespace topological_space -- hide\n\n/- Lemma\nLet \u03c4 be a topological space. If \u03c4 is a frechet space is also a T\u2080.\n-/\nlemma T1_is_T0: T1_space X \u2192 T0_space X :=\nbegin\n", "proof": "  introI t1,\n  fconstructor,\n  intros x y hxy,\n  obtain \u27e8U, hU, hh\u27e9:= T1_space.t1 x y hxy,\n  exact \u27e8U, hU, or.inl hh\u27e9,\n\n\n\n\n\n\n\n\n", "textAfter": "\nend\n\nend topological_space -- hide\n", "height": 14, "editorText": "sorry", "lineOffset": 25, "name": "T1_is_T0", "statement": "T1_space X \u2192 T0_space X"}, {"type": "lean", "content": "138", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "139", "hidden": true}, {"type": "text", "content": "140"}, {"type": "lean", "content": "141", "hidden": true}, {"type": "lean", "content": "142", "hidden": true}, {"type": "lean", "content": "143", "hidden": true}, {"type": "lemma", "text": "144", "lean": "lemma T1_space_iff_T1_space' : T1_space X \u2194 T1_space' X:=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 31, "textBefore": "import separation_world.level1 -- hide\n\n/-\n# Level 2: Comparison between the definition given and common definition of T\u2081\n-/\n\nvariables {X : Type} -- hide\nvariables [topological_space X] -- hide\n\nnamespace topological_space -- hide\n\n\n/- Lemma\nThe definitions T1_space and T1_space' are equivalent.\n-/\nlemma T1_space_iff_T1_space' : T1_space X \u2194 T1_space' X:=\nbegin\n", "proof": "  split; introI h,\n  { fconstructor,\n    intros x y hxy,\n    obtain \u27e8U, hU, hhU\u27e9 := T1_space.t1 x y hxy,\n    obtain \u27e8V, hV, hhV\u27e9 := T1_space.t1 y x (ne.symm hxy),\n    exact \u27e8U, V, hU, hV, hhU.1, hhU.2, hhV.2, hhV.1\u27e9},\n  { fconstructor,\n    intros x y hxy,\n    obtain \u27e8U, V, hU, hV, hh\u27e9 := T1_space'.t1 x y hxy,\n    exact \u27e8U, hU, \u27e8hh.1,hh.2.1\u27e9\u27e9},\n\n\n\n", "textAfter": "\nend\n\n\nend topological_space -- hide\n", "height": 14, "editorText": "sorry", "lineOffset": 17, "name": "T1_space_iff_T1_space'", "statement": "T1_space X \u2194 T1_space' X"}, {"type": "lean", "content": "145", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "146", "hidden": true}, {"type": "text", "content": "147"}, {"type": "lean", "content": "148", "hidden": true}, {"type": "lean", "content": "149", "hidden": true}, {"type": "lean", "content": "150", "hidden": true}, {"type": "lean", "content": "151", "hidden": true}, {"type": "lemma", "text": "152", "lean": "lemma union_disjont_open_sets [T1_space X] {x : X}: \u22c3\u2080 {U : set X | (x \u2209 U) \u2227 (is_open U)} = {x}\u1d9c :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 24, "textBefore": "import separation_world.level2 -- hide\n\n/-\n# Level 3: Lemma about intersection of open sets\n-/\n\nvariables {X : Type} -- hide\nvariables [topological_space X] -- hide\n\nnamespace topological_space -- hide\nopen set -- hide\n\n/- Lemma\nLet \u03c4 be a topological space. \u03c4 is a frechet space if only if for all the points in the topology, their singletons are closed sets.\n-/\nlemma union_disjont_open_sets [T1_space X] {x : X}: \u22c3\u2080 {U : set X | (x \u2209 U) \u2227 (is_open U)} = {x}\u1d9c :=\nbegin\n", "proof": "  apply subset.antisymm; intros t ht, \n  { rcases ht with \u27e8A,\u27e8hxA, hA\u27e9, htA\u27e9,\n    rw [mem_compl_eq, mem_singleton_iff],\n    rintro rfl,\n    contradiction},\n  { obtain \u27e8U, hU, hh\u27e9 := T1_space.t1 t x (mem_compl_singleton_iff.mp ht).symm,\n    exact \u27e8U, \u27e8hh.2, hU\u27e9, hh.1\u27e9},", "textAfter": "\nend\n\nend topological_space -- hide\n", "height": 7, "editorText": "sorry", "lineOffset": 17, "name": "union_disjont_open_sets", "statement": "[T1_space X] {x : X}: \u22c3\u2080 {U : set X | (x \u2209 U) \u2227 (is_open U)} = {x}\u1d9c"}, {"type": "lean", "content": "153", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "154", "hidden": true}, {"type": "text", "content": "155"}, {"type": "lean", "content": "156", "hidden": true}, {"type": "lean", "content": "157", "hidden": true}, {"type": "lean", "content": "158", "hidden": true}, {"type": "lean", "content": "159", "hidden": true}, {"type": "lemma", "text": "160", "lean": "lemma T1_characterisation : T1_space X \u2194 (\u2200 (x : X), is_closed ({x} : set X)) :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 23, "textBefore": "import separation_world.level3 -- hide\n\n/-\n# Level 4: Characterisation of Frechet spaces\n-/\n\nvariables {X : Type} -- hide\nvariables [topological_space X] -- hide\n\nnamespace topological_space -- hide\nopen set -- hide\n\n/- Lemma\nLet \u03c4 be a topological space. \u03c4 is a frechet space if only if for all the points in the topology, their singletons are closed sets.\n-/\nlemma T1_characterisation : T1_space X \u2194 (\u2200 (x : X), is_closed ({x} : set X)) :=\nbegin\n", "proof": "  split,\n  { introsI t1 x,\n    rw [is_closed, \u2190 union_disjont_open_sets],\n    exact topological_space.union {U : set X | (x \u2209 U) \u2227 (is_open U)} (\u03bb B hB, hB.2)},\n  { intro h, \n    exact \u27e8\u03bb x y hxy, \u27e8{y}\u1d9c,h y, mem_compl_singleton_iff.mpr (ne.symm hxy), not_not.mpr rfl\u27e9\u27e9}", "textAfter": "\nend\n\nend topological_space -- hide\n", "height": 6, "editorText": "sorry", "lineOffset": 17, "name": "T1_characterisation", "statement": "T1_space X \u2194 (\u2200 (x : X), is_closed ({x} : set X))"}, {"type": "lean", "content": "161", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "162", "hidden": true}, {"type": "text", "content": "163"}, {"type": "lean", "content": "164", "hidden": true}, {"type": "lean", "content": "165", "hidden": true}, {"type": "lean", "content": "166", "hidden": true}, {"type": "lean", "content": "167", "hidden": true}, {"type": "lemma", "text": "168", "lean": "lemma T2_space.T1_space [T2_space X]: T1_space X  :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 24, "textBefore": "import separation_world.level4 -- hide\n\n/-\n# Level 5: Every T\u2082 space is also T\u2081\n-/\n\nvariables {X : Type} -- hide\nvariables [topological_space X] -- hide\n\nnamespace topological_space -- hide\nopen set -- hide\n\n/- Lemma\nLet \u03c4 be a topological space. \u03c4 is a frechet space if only if for all the points in the topology, their singletons are closed sets.\n-/\nlemma T2_space.T1_space [T2_space X]: T1_space X  :=\nbegin\n", "proof": "  exact {t1 := \u03bb x y hxy, let \u27e8U, V, hU, hV, hUV, hh\u27e9  := T2_space.t2 x y hxy in \n          \u27e8U, hU, hh.1, not.imp (not_not.mpr hh.2) (\u03bb c, (subset_compl_iff_disjoint.2 hUV) c)\u27e9 }\n\n\n\n\n          ", "textAfter": "\nend\n\nend topological_space -- hide\n", "height": 7, "editorText": "sorry", "lineOffset": 17, "name": "T2_space.T1_space", "statement": "[T2_space X]: T1_space X"}, {"type": "lean", "content": "169", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "170", "hidden": true}, {"type": "text", "content": "171"}, {"type": "lean", "content": "172", "hidden": true}, {"type": "lean", "content": "173", "hidden": true}, {"type": "lean", "content": "174", "hidden": true}, {"type": "lean", "content": "175", "hidden": true}, {"type": "lemma", "text": "176", "lean": "lemma T3_space.T1_space [T3_space X]: T1_space X  :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 30, "textBefore": "import separation_world.level5 -- hide\n\n/-\n# Level 6: Characterisation of Frechet spaces\n-/\n\nvariables {X : Type} -- hide\nvariables [topological_space X] -- hide\n\nnamespace topological_space -- hide\nopen set -- hide\n\n/- Lemma\nLet \u03c4 be a topological space. \u03c4 is a frechet space if only if for all the points in the topology, their singletons are closed sets.\n-/\nlemma T3_space.T1_space [T3_space X]: T1_space X  :=\nbegin\n", "proof": "  fconstructor,\n  intros x y hxy,\n  obtain \u27e8U, hU, hh\u27e9 := T0_space.t0 x y hxy,\n  cases hh,\n  { exact \u27e8U, hU, hh\u27e9},\n  { obtain \u27e8A, B, hA, hB, hAB, hhAB\u27e9 := T3_space.regular y U\u1d9c (by rwa [is_closed, compl_compl]) \n                                          (\u03bb t, (not_mem_of_mem_compl t) hh.2),\n    exact \u27e8B, hB, hhAB.2 hh.1, (disjoint_left.1 (disjoint_iff_inter_eq_empty.2 hAB) hhAB.1)\u27e9}\n\n\n\n    \n  ", "textAfter": "\nend\n\nend topological_space -- hide\n", "height": 13, "editorText": "sorry", "lineOffset": 17, "name": "T3_space.T1_space", "statement": "[T3_space X]: T1_space X"}, {"type": "lean", "content": "177", "hidden": true}]}], "parents": [2]}], "texts": [["Lean Topology game", "# The Topology Game, version 1.0.0.\n\n## By the Barcelona Lean Seminar\n\nLearn topology with LEAN!\n\n# What is this game?\n\nIn this game, you will learn topology and Lean at the same time. Have fun!\n\n# Credits\n\nThe Topology Game is brought to you by the Barcelona Lean Seminar, a project based at Universitat Aut\u00f2noma de Barcelona.\n\nLean is a computer theorem prover being developed at Microsoft Research.\n\nProve a theorem. Write a function. <a href=\"https://twitter.com/XenaProject\" target=\"blank\">@XenaProject</a>.\n", "Set theory", "\n## Summary\n\n`refl` proves goals of the form `X = X`.\n\n## Details\n\nThe `refl` tactic will close any goal of the form `A = B`\nwhere `A` and `B` are *exactly the same thing*.\n\n### Example:\nIf it looks like this in the top right hand box:\n```\na b c d : mynat\n\u22a2 (a + b) * (c + d) = (a + b) * (c + d)\n```\n\nthen\n\n`refl,`\n\nwill close the goal and solve the level. Don't forget the comma.\n\n", "We will start by practising with the simplest tactic, namely *refl*. This just proves goals\nof the form $A = A$, no matter how complicated $A$ is. Let's see it in action!\n", "Just delete `sorry` and type `refl,` (don't forget the comma!).\n", "Click here for a hint, in case you get stuck.", "variables {X : Type} -- hide\n", "If A and B are sets, then A \u222a B = A \u222a B.\n", "\n## Summary\n\nIf `h` is a proof of `X = Y`, then `rw h,` will change\nall `X`s in the goal to `Y`s. Variants: `rw \u2190 h` (changes\n`Y` to `X`) and\n`rw h at h2` (changes `X` to `Y` in hypothesis `h2` instead\nof the goal).\n\n## Details\n\nThe `rw` tactic is a way to do \"substituting in\". There\nare two distinct situations where use this tactics.\n\n1) If `h : A = B` is a hypothesis (i.e., a proof of `A = B`)\nin your local context (the box in the top right)\nand if your goal contains one or more `A`s, then `rw h`\nwill change them all to `B`'s. \n\n2) The `rw` tactic will also work with proofs of theorems\nwhich are equalities (look for them in the drop down\nmenu on the left, within Theorem Statements).\n\nImportant note: if `h` is not a proof of the form `A = B`\nor `A \u2194 B` (for example if `h` is a function, an implication,\nor perhaps even a proposition itself rather than its proof),\nthen `rw` is not the tactic you want to use. For example,\n`rw (P = Q)` is never correct: `P = Q` is the true-false\nstatement itself, not the proof.\nIf `h : P = Q` is its proof, then `rw h` will work.\n\nPro tip 1: If `h : A = B` and you want to change\n`B`s to `A`s instead, try `rw \u2190h` (get the arrow with `\\l` and\nnote that this is a small letter L, not a number 1).\n\n### Example:\nIf it looks like this in the top right hand box:\n```\nA B C : set X\nh : A = B \u222a C\n\u22a2 A \u222a B = B \u222a C\n```\n\nthen\n\n`rw h,`\n\nwill change the goal into `\u22a2 B \u222a C \u222a B = B \u222a C`.\n\n### Example: \nYou can use `rw` to change a hypothesis as well. \nFor example, if your local context looks like this:\n```\nA B C D : set X\nh1 : A = B \u2229 C\nh2 : B \u222a A = D\n\u22a2 D = B\n```\nthen `rw h1 at h2` will turn `h2` into `h2 : B \u222a B \u2229 C = D` (remember operator precedence).\n", "The next tactic we will learn is *rw* (from rewrite). It rewrites equalities. That is,\nif we have a proof `h : x = 3` and we want to prove `\u22a2 x + 1 = 4`, then after `rw h` the goal\nwill become `\u22a2 3 + 1 = 4`, which seems reasonable.\n\n", "Delete `sorry` and type `rw h,` (don't forget the comma!). Lean tries `refl` afterwards,\nso you will see that this suffices.\n", "Click here for a hint, in case you get stuck.", "variables {X : Type} -- hide\n", "If A, B and C are sets and A = B, then A \u222a C = B \u222a C.\n", "\n## Summary \n\nIf the goal is `\u22a2 X` then `exact x` will close the goal if\nand only if `x` is a term of type `X`. \n\n## Details\n\nSay $P$, $Q$ and $R$ are types (i.e., what a mathematician\nmight think of as either sets or propositions),\nand the local context looks like this: \n\n```\np : P,\nh : P \u2192 Q,\nj : Q \u2192 R\n\u22a2 R\n```\n\nIf you can spot how to make a term of type `R`, then you\ncan just make it and say you're done using the `exact` tactic\ntogether with the formula you have spotted. For example the\nabove goal could be solved with\n\n`exact j(h(p)),`\n\nbecause $j(h(p))$ is easily checked to be a term of type $R$\n(i.e., an element of the set $R$, or a proof of the proposition $R$).\n\n", "In this level we learn the tactic `exact`, which solves a goal that is exactly one of the hypotheses.\n", "By doing a `rw` you will get the goal to look exactly like one of the hypotheses...\n", "Click here for a hint, in case you get stuck.", "variables {X : Type} -- hide\n", "If A and B are sets and x \u2208 A and A = B, then x \u2208 B.\n", "\n\n`rwa` uses the rewrite tactic and then uses `exact` with all \nthe assumptions of the proof.\n\n", "The next tactic we will learn is `rwa` which applies rewrite tactic and then uses `exact` with all the hypotheses.\n", "variables {X : Type} -- hide\n", "Let A be a set and x \u2208 A, using the assumption A \u222a A = A, we obtain that x \u2208 B.\n", "\n## Summary:\n\n`intro p` will turn a goal `\u22a2 P \u2192 Q` into a hypothesis `p : P`\nand goal `\u22a2 Q`. If `P` and `Q` are sets `intro p` means \"let $p$ be an arbitrary element of $P$\".\nIf `P` and `Q` are propositions then `intro p` says \"assume $P$ is true\". \n\n## Details\n\nIf your goal is a function or an implication `\u22a2 P \u2192 Q` then `intro`\nwill always make progress. `intro p` turns\n\n`\u22a2 P \u2192 Q`\n\ninto \n\n```\np : P\n\u22a2 Q\n```\n\nThe opposite tactic to intro is `revert`; given the situation\njust above, `revert p` turns the goal back into `\u22a2 P \u2192 Q`.\n\n## Example\n\nIf your goal is an implication $P\\implies Q$ then Lean writes\nthis as `\u22a2 P \u2192 Q`, and `intro p,` can be thought of as meaning\n\"let $p$ be a proof of $P$\", or more informally \"let's assume that\n$P$ is true\". The goal changes to `\u22a2 Q` and the hypothesis `p : P`\nappears in the local context.\n", "In this level we introduce the tactic `intro`. You will need it to get started.\n", "Try something like `intro h1,` and go from there.\n", "Click here for a hint, in case you get stuck.", "variables {X : Type} -- hide\n", "If A, B and C are sets and A = B, then A \u222a C = B \u222a C.\n", "import data.set.basic -- hide\n", "open set -- hide\n", "\n## Summary\n\nIf `h : P \u2192 Q` is a hypothesis, and the goal is `\u22a2 Q` then\n`apply h` changes the goal to `\u22a2 P`. \n\n## Details\n\nIf you have a function `h : P \u2192 Q` and your goal is `\u22a2 Q`\nthen `apply h` changes the goal to `\u22a2 P`. The logic is\nsimple: if you are trying to create a term of type `Q`,\nbut `h` is a function which turns terms of type `P` into\nterms of type `Q`, then it will suffice to construct a\nterm of type `P`. A mathematician might say: \"we need\nto construct an element of $Q$, but we have a function $h:P\\to Q$\nso it suffices to construct an element of $P$\". Or alternatively\n\"we need to prove $Q$, but we have a proof $h$ that $P\\implies Q$\nso it suffices to prove $P$\".\n\n", "In this level we introduce the new tactic `apply`. Look at what it does and try to solve it!\n", "Start with an `intro`, then try to `apply` the right hypothesis.\n", "Click here for a hint, in case you get stuck.", "variables {X Y : Type} -- hide\n", "If A, B and C are sets and x \u2208 A, and we know that x \u2208 A \u2192 x \u2208 B and that x \u2208 B \u2192 x \u2208 C, then\nwe can deduce that x \u2208 C.\n", "import data.set.basic -- hide\n", "open set -- hide\n", "There is an equivalence between set theory and logic, and Lean identifies these two.\n\nIn this equivalence, a logic statement P : X \u2192 true/false corresponds to the set\n$A = \\{ x : X | P(x) \\}$. Under this equivalence, logical implications P \u2192 Q translate into\nset inclusions A \u2286 B, and so on.\n\nThe goal of this lemma is to prove transitivity of set inclusion, giving almost the same\nproof as in the previous lemma.\n", "Start with `intro x,`, then do exactly as in the previous level.\n", "Click here for a hint, in case you get stuck.", "variables {X Y : Type} -- hide\n", "If A, B and C are sets and, and we know A \u2286 B and B \u2286 C, then\nwe have A \u2286 C.\n", "import data.set.basic -- hide\n", "open set -- hide\n", "\n## Summary\n\nChanges the goal to `\u22a2 false`.\n\n## Details\n\nThis may seem hard to prove,\nbut it is useful when we have a contradiction in the hypotheses.\n\nFor example, if we have `h : \u00ac P` as a hypothesis and we apply `exfalso`\nwe can then `apply h` to transform the goal into `\u22a2 P`.\n", "In Lean, the  negation `\u00ac P` of a statement is a shorthand for `P \u2192 false`. Therefore\nstart with `exfalso`, and remember that negation is the same as `\u2192 false`.\n", "Click here for a hint, in case you get stuck.", "variables {X Y : Type} -- hide\n", "We can prove that 1 equals 0 if we have a contradiction in our hypotheses.\n", "import data.set.basic -- hide\n", "open set -- hide\n", "The following lemma can be proved using `ext`, `split`, `cases`, `left`, `right` tactics.\n\nIf you are lazy, the `finish` tactic will take the fun out of this exercise. So try to not use it.\n", "Remember that `x \u2208 A \u2229 B` is \"the same as\" `x \u2208 A \u2227 x \u2208 B`. Therefore if you have a hypothesis\nof the form `h : x \u2208 A \u2229 B` and your goal is `\u22a2 x \u2208 B`, you win by `exact h.2`.\n", "Click here for a hint, in case you get stuck.", "variables {X Y : Type} -- hide\n", "The distributive property of \u2229 with respect to \u222a.\n", "import data.set.basic -- hide\n", "import data.set.finite -- hide\n", "open set -- hide\n", "We will use the following lemma when we start proving facts about topological spaces.\n\nIt seems clear that we want to use induction, so we can try to apply the `finite.induction_on`\nlemma. But be careful on how you apply it, or you will be left with an impossible goal.\n\nFor the inductive step, the lemmas `sInter_insert`, `mem_insert_iff` and `forall_eq_or_imp`\nmay be useful, as well as the `simp` tactic.\n", "The `finite.induction_on` lemma allows to prove something of the form `P S` for all finite sets `S`.\nSo apply `finite.induction_on hfin` looks like it's making progress. However, the induction\nhypothesis you will be left with is too weak. Try instead starting with `revert hS`, and\nsee why this helps.\n", "Click here for a hint, in case you get stuck.", "variables {X Y : Type} -- hide\n", "If P is a property of sets which is closed under pairwise intersection then it is also closed under\narbitrary finite interesctions.\n", "Basic definitions", "import basic_defs_world.definition -- hide\n", "univ_mem : is_open set.univ\n", "inter : \u2200 (U V : set X) (hA : is_open U) (hB : is_open V), is_open (U \u2229 V)\n", "union : \u2200 (Y : set (set X)) (h : \u2200 U \u2208 Y, is_open U), is_open (\u22c3\u2080 Y)\n", "sUnion_empty : \u22c3\u2080 \u2205 = \u2205\n", "# Level 1 : The empty set is open.\n", "noncomputable theory -- hide\n", "open set -- hide\n", "In many textbooks, one of the axioms of a topological space is that the empty set is open. This actually follows from the other axioms!\n", "namespace topological_space -- hide\n", "In Lean, sets are notation for logical statements. That is, the set\n`a \u2208 { x : X | P x }` means *the same as* `P a`. As a somewhat degenerate\nexample, `a \u2208 \u2205` means `false`.\n", "Click here for a hint, in case you get stuck.", "Prove that the empty set is open.\n", "end topological_space -- hide\n", "import .level1 -- hide\n", "open set --hide\n", "namespace topological_space -- hide\n", " # Level 2: The union of two open sets is open\n", "Prove that the union of two open sets is open.\n", "end topological_space --hide", "Interior world", "import interior_world.definition -- hide\n", "is_neighborhood : \u2203 U, is_open U \u2227 x \u2208 U \u2227 U \u2286 A\n", "is_interior_point : is_neighborhood x A\n", "interior : { x : X | is_interior_point x A }\n", "In this world we will end up having three alternative definitions of the interior of a set. \nThis will be very useful, because at any point we will be able to choose the one that better fits our needs.\n\nFirst of all we need to figure out what properties does the interior of an arbitrary set have... So we start with an easy one:\n\n# Level 1: The interior is contained in the original set\n\n", "variables {X : Type} -- hide\n", "variables [topological_space X] (x : X)  (A : set X) -- hide\n", "namespace topological_space -- hide\n", "@[simp]  -- hide\n", "The interior of any set A is contained in the set A.\n", "end topological_space -- hide\n", "import interior_world.level1 --hide\n", "\n# Level 2: Second definition of the interior\n\nBefore we keep proving properties of the iterior of an arbitrary set, we will prove an alternative definition of it.\n\n", "variables {X : Type} -- hide\n", "variables [topological_space X] (x : X)  (A : set X) -- hide\n", "namespace topological_space -- hide\n", "The interior of a set A is the union of all the open sets that it contains:\n$ \\operatorname{int}(A) = \\bigcup_{U \\subseteq A, U\\text{ open}} U$\n", "end topological_space -- hide\n", "import interior_world.level2 --hide\n", "\n# Level 3: The interior is open\n\n\n\n", "variables {X : Type} -- hide\n", "variables [topological_space X] (x : X)  (A : set X) -- hide\n", "namespace topological_space -- hide\n", "The interior of a set is open.\n", "end topological_space -- hide\n", "import interior_world.level3 --hide\n", "\n# Level 4: The interior is ...\n\n\n\n", "variables {X : Type} -- hide\n", "variables [topological_space X] (x : X)  (A : set X) -- hide\n", "namespace topological_space -- hide\n", "The interior of a set ...\n", "end topological_space -- hide\n", "import interior_world.level4 --hide\n", "\n# Level 5: Characterization of the interior\n\n\n\n", "variables {X : Type} -- hide\n", "variables [topological_space X] (x : X)  (A B : set X) -- hide\n", "namespace topological_space -- hide\n", "The interior of a set A is the biggest subset satisfying:\n - It is contained in A\n - It is open.\n", "end topological_space -- hide\n", "Separation world", "import separation_world.definition -- hide\n", "t0 : \u2200 (x y : X) (h : y \u2260 x) , \u2203 (U : set X) (hU : is_open U), ((x \u2208 U) \u2227 (y \u2209 U)) \u2228 ((x \u2209 U) \u2227 (y \u2208 U))\n", "t1 : \u2200 (x y : X) (h : y \u2260 x), \u2203 (U : set X) (hU : is_open U), (x \u2208 U) \u2227 (y \u2209 U)\n", "\n# Level 1: Every Frechet space is a T\u2080 space\n\n", "variables {X : Type} -- hide\n", "variables [topological_space X] -- hide\n", "namespace topological_space -- hide\n", "Let \u03c4 be a topological space. If \u03c4 is a frechet space is also a T\u2080.\n", "end topological_space -- hide\n", "import separation_world.level1 -- hide\n", "# Level 2: Comparison between the definition given and common definition of T\u2081\n", "variables {X : Type} -- hide\n", "variables [topological_space X] -- hide\n", "namespace topological_space -- hide\n", "The definitions T1_space and T1_space' are equivalent.\n", "end topological_space -- hide\n", "import separation_world.level2 -- hide\n", "# Level 3: Lemma about intersection of open sets\n", "variables {X : Type} -- hide\n", "variables [topological_space X] -- hide\n", "namespace topological_space -- hide\n", "open set -- hide\n", "Let \u03c4 be a topological space. \u03c4 is a frechet space if only if for all the points in the topology, their singletons are closed sets.\n", "end topological_space -- hide\n", "import separation_world.level3 -- hide\n", "# Level 4: Characterisation of Frechet spaces\n", "variables {X : Type} -- hide\n", "variables [topological_space X] -- hide\n", "namespace topological_space -- hide\n", "open set -- hide\n", "Let \u03c4 be a topological space. \u03c4 is a frechet space if only if for all the points in the topology, their singletons are closed sets.\n", "end topological_space -- hide\n", "import separation_world.level4 -- hide\n", "# Level 5: Every T\u2082 space is also T\u2081\n", "variables {X : Type} -- hide\n", "variables [topological_space X] -- hide\n", "namespace topological_space -- hide\n", "open set -- hide\n", "Let \u03c4 be a topological space. \u03c4 is a frechet space if only if for all the points in the topology, their singletons are closed sets.\n", "end topological_space -- hide\n", "import separation_world.level5 -- hide\n", "# Level 6: Characterisation of Frechet spaces\n", "variables {X : Type} -- hide\n", "variables [topological_space X] -- hide\n", "namespace topological_space -- hide\n", "open set -- hide\n", "Let \u03c4 be a topological space. \u03c4 is a frechet space if only if for all the points in the topology, their singletons are closed sets.\n", "end topological_space -- hide\n"]]}